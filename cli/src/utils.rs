use anchor_client::solana_sdk::commitment_config::CommitmentConfig;
use anchor_client::ClientError;

use anyhow::Result;
use chrono::prelude::*;
//use mpl_token_metadata::pda::{find_master_edition_account, find_metadata_account};
use solana_client::rpc_client::RpcClient;
use solana_sdk::program_pack::Pack;
use spl_associated_token_account::get_associated_token_address;
use spl_token::state::Account as TokenAccount;
use tokio::runtime::Runtime;

// The `accounts` and `instructions` modules are generated by the framework.
//use events::instruction as events_instruction;
//use events::MyEvent;

// The `accounts` and `instructions` modules are generated by the framework.
//use composite::accounts::{Bar, CompositeUpdate, Foo, Initialize};
//use composite::instruction as composite_instruction;
//use composite::{DummyA, DummyB};

use std::str::FromStr;

use anchor_client::anchor_lang::prelude::Pubkey;

//use mpl_token_metadata::{find_master_edition_account, find_metadata_account};

#[cfg(feature = "serde-feature")]
use {
    serde::{Deserialize, Serialize},
    serde_with::{As, DisplayFromStr},
};

//import { TOKEN_PROGRAM_ID, createAssociatedTokenAccountInstruction, getAssociatedTokenAddress, createInitializeMintInstruction, MINT_SIZE } from '@solana/spl-token' // IGNORE THESE ERRORS IF ANY

use solana_sdk::account::ReadableAccount;

use crate::MPL_TOKEN_METADATA_ACCOUNT;

use mpl_token_metadata::ID as METAPLEX_PROGRAM_ID;

/***
pub fn find_metadata_pda(mint: &Pubkey) -> Pubkey {
    let (pda, _bump) = find_metadata_account(mint);

    pda
}

pub fn find_master_edition_pda(mint: &Pubkey) -> Pubkey {
    let (pda, _bump) = find_master_edition_account(mint);
    pda
}
*/

pub fn get_acc(address: Pubkey) -> solana_sdk::account::Account {
    let rpc_client = RpcClient::new("https://api.mainnet-beta.solana.com".to_string());
    rpc_client
        .get_account_with_commitment(&address, CommitmentConfig::processed())
        .unwrap()
        .value
        .ok_or(ClientError::AccountNotFound)
        .unwrap()
}

//根据get_program_account过滤相关ata
// pub fn get_token_account_by_wallet(wallet_pubkey: Pubkey, mint_pubkey: Pubkey) -> Option<Pubkey> {
//     let rpc_url = String::from("https://api.mainnet-beta.solana.com");
//     let connection = RpcClient::new_with_commitment(rpc_url, CommitmentConfig::confirmed());

//     let filters = Some(vec![
//         RpcFilterType::Memcmp(Memcmp {
//             offset: 32,
//             bytes: MemcmpEncodedBytes::Base58(wallet_pubkey.to_string()),
//             encoding: Some(MemcmpEncoding::Binary),
//         }),
//         RpcFilterType::DataSize(165),
//     ]);

//     let accounts = connection
//         .get_program_accounts_with_config(
//             &Pubkey::from_str(SPL_PROGRAM_ID).unwrap(),
//             RpcProgramAccountsConfig {
//                 filters,
//                 account_config: RpcAccountInfoConfig {
//                     encoding: Some(UiAccountEncoding::Base64),
//                     commitment: Some(connection.commitment()),
//                     ..RpcAccountInfoConfig::default()
//                 },
//                 ..RpcProgramAccountsConfig::default()
//             },
//         )
//         .unwrap();

//     println!(
//         "Found {:?} token account(s) for wallet {}: ",
//         accounts.len(),
//         wallet_pubkey.to_string()
//     );
//     let token_account = accounts.iter().find(|&account| {
//         let mint_token_account = Account::unpack_from_slice(account.1.data.as_slice()).unwrap();
//         let mint_token_account = mint_token_account.mint.to_string();
//         mint_pubkey.to_string() == mint_token_account
//     });
//     //todo: 不仅检查是否在当前program找到，还要检查所有的
//     token_account.map(|token_account| token_account.0.to_owned())
// }

pub fn get_lamport_balance(account_address: &Pubkey) -> Result<u64> {
    let rpc_url = unsafe { crate::RPC.as_deref().unwrap() };
    //let prikey = unsafe { crate::PRIKEY.as_deref().unwrap() };
    let client = RpcClient::new(rpc_url);
    Ok(client.get_balance(account_address)?)
}

pub fn get_token_balance(token_mint: &Pubkey, account_address: &Pubkey) -> Result<u64> {
    //let mint_pubkey = unsafe { TOKEN_MINT.unwrap() };
    let rpc_url = unsafe { crate::RPC.as_deref().unwrap() };
    let prikey = unsafe { crate::PRIKEY.as_deref().unwrap() };

    let client = RpcClient::new_with_commitment(rpc_url.to_string(), CommitmentConfig::confirmed());

    let user_staking_wallet = get_associated_token_address(account_address, token_mint);

    // 获取SPL Token账户信息
    let account_info = match client.get_account(&user_staking_wallet) {
        Ok(account) => account,
        Err(_) => return Ok(0),
    };

    // decode token account
    let token_account =
        TokenAccount::unpack(&account_info.data).expect("Failed to unpack token account");

    let balance = token_account.amount;
    Ok(balance)
}

pub fn current_date() -> String {
    let dt: DateTime<Local> = Local::now();
    dt.format("%Y-%m-%d %H:%M:%S.%f").to_string()
}

pub fn current_timestamp() -> i64 {
    let dt: DateTime<Local> = Local::now();
    dt.timestamp()
}

pub fn find_metadata_pda(mint: &Pubkey) -> Pubkey {
    let metadata_program = Pubkey::from_str(MPL_TOKEN_METADATA_ACCOUNT).unwrap();
    let (pda, _bump) = Pubkey::find_program_address(
        &[
            "metadata".as_bytes(),
            metadata_program.as_ref(),
            mint.as_ref(),
        ],
        &metadata_program,
    );

    pda
}

pub fn find_master_edition_pda(mint: &Pubkey) -> Pubkey {
    let seeds = &[
        "metadata".as_bytes(),
        METAPLEX_PROGRAM_ID.as_ref(),
        mint.as_ref(),
        "edition".as_bytes(),
    ];
    let (pda, _bump) = Pubkey::find_program_address(seeds, &METAPLEX_PROGRAM_ID);
    pda
}

pub fn is_test() -> bool {
    match std::env::var("TEST") {
        Ok(x) if x.eq("true") => true,
        _ => false,
    }
}

use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
struct Msg {
    msg_type: String,
    content: Text,
}

#[derive(Debug, Serialize, Deserialize)]
struct Text {
    text: String,
}
pub fn notify_lark(pushed_msg: &str) -> Result<(), anyhow::Error> {
    //println!("increase_ratio {},increase_volume {}",increase_price,increase_volume);
    let data = Msg {
        msg_type: "text".to_string(),
        content: Text {
            text: pushed_msg.to_owned(),
        },
    };
    let client = reqwest::Client::new();
    let rt = Runtime::new().unwrap();

    rt.block_on(async {
        let res = client
            //pro
            //.post("https://open.feishu.cn/open-apis/bot/v2/hook/d61a3182-a797-42e3-a599-58a97c124e7b")
            //test
            .post(
                "https://open.feishu.cn/open-apis/bot/v2/hook/d0ab67aa-9aee-4a92-9908-4d66844a7e50",
            )
            .json(&data)
            .header("Content-type", "application/json")
            .header("charset", "utf-8")
            .send()
            .await
            .expect("send lark msg should be ok");
        //println!("send lark msg res: {:?}", res.text().await.unwrap());
    });
    //send to lark
    Ok(())
}
